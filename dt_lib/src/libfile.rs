use std::cmp::{max};

use crate::error::Error as LibError;

pub struct ExtDict {
    pub entries: usize,
    pub offset: usize,
}

pub struct Parser<'a> {
    pub image: &'a [u8],
    pub ptr: usize,
    pub start: usize,
    pub next: usize,
    pub pagesize: usize,
    pub dictoffset: usize,
    pub dictblocks: usize,
    pub case_sensitive: bool,
    pub edict: Option<ExtDict>,
}

struct LibHash {
    block_x: u16,
    block_d: u16,
    bucket_x: u16,
    bucket_d: u16,
}

const LIB_BLOCK_SIZE: usize = 512;
const LIB_NBUCKETS: usize = 37;

impl<'a> Parser<'a> {
    const MIN_HEADER_LENGTH: usize = 10;
    const LIB_HEADER: u8 = 0xf0;
    const MODEND: u8 = 0x8a;
    const MODEND32: u8 = 0x8b;

    fn err(&self, err: &str) -> LibError {
        LibError::with_offset(err, self.start)
    }

    fn endrec(&self) -> usize {
        // record end does not include checksum byte
        self.next - 1
    }

    fn uint(data: &[u8]) -> usize {
        let bytes = data.len();
        let mut value: usize = 0;
    
        for i in 1..bytes+1 {
            let byte = data[bytes - i] as usize;
            value = (value << 8) | byte;
        }
    
        value
    }

    fn next_uint(&mut self, size: usize) -> Result<usize, LibError> {
        if self.ptr + size > self.endrec() {
            Err(self.err("next_uint: record is truncated"))
        } else {
            let value = Self::uint(&self.image[self.ptr..self.ptr+size]);
            self.ptr += size;
            Ok(value)
        }
    }

    pub fn is_lib(image: &[u8]) -> bool {
        image.len() >= Self::MIN_HEADER_LENGTH && image[0] == Self::LIB_HEADER 
    }

    pub fn new(image: &'a [u8]) -> Result<Parser<'a>, LibError> {
        if !Self::is_lib(&image) {
            return Err(LibError::new("image is not a library"));
        }
        
        let next = image.len();

        let reclen = Self::uint(&image[1..3]);
        let dictoffset = Self::uint(&image[3..7]);
        let dictblocks = Self::uint(&image[7..9]);
        let flags = image[9];

        if dictoffset >= image.len() {
            return Err(LibError::new("library is corrupt (no or invalid dictionary)"));
        }

        let edict_start = dictoffset + dictblocks * LIB_BLOCK_SIZE;

        const EDICT_HEADER_LEN: usize = 5;
        const EDICT_HEADER_TYPE: u8 = 0xf2;

        let edict = if edict_start + EDICT_HEADER_LEN <= image.len() && image[edict_start] == EDICT_HEADER_TYPE {
            let len = Self::uint(&image[edict_start+1..edict_start+3]);
            let entries = Self::uint(&image[edict_start+3..edict_start+5]);
            let offset = edict_start + EDICT_HEADER_LEN;
            
            // NB length includes 16-bit entries word which is before edict_offset
            if offset - 2 + len < image.len() {
                None
            } else {
                Some(ExtDict{ offset, entries })
            }
        } else {
            None
        };

        Ok(Parser {
            image,
            ptr: 0,
            start: 0,
            next,
            pagesize: reclen + 3,
            dictoffset,
            dictblocks,
            case_sensitive: (flags & 0x01) != 0,
            edict,
        })
    }

    pub fn first_obj(&mut self) -> Result<Option<&[u8]>, LibError> {
        self.ptr = self.pagesize;
        let start = self.ptr;

        loop {
            let rectype = self.next_uint(1)? as u8;
            let reclen = self.next_uint(2)?;

            self.ptr += reclen;

            if rectype == Self::MODEND || rectype == Self::MODEND32 {
                break;
            }
        }

        if self.ptr > self.dictoffset {
            return Err(self.err("object file ran over into dictionary"));
        }

        let end = self.ptr;
        self.ptr = (self.ptr + self.pagesize - 1) & !(self.pagesize - 1);

        Ok(Some(&self.image[start..end]))
    }

    pub fn next_obj(&mut self) -> Result<Option<&[u8]>, LibError> {
        let start = self.ptr;

        if start >= self.dictoffset {
            return Ok(None);
        }

        loop {
            let rectype = self.next_uint(1)? as u8;
            let reclen = self.next_uint(2)?;

            self.ptr += reclen;

            if rectype == Self::MODEND || rectype == Self::MODEND32 {
                break;
            }
        }

        if self.ptr > self.dictoffset {
            return Err(self.err("object file ran over into dictionary"));
        }

        let end = self.ptr;
        self.ptr = (self.ptr + self.pagesize - 1) & !(self.pagesize - 1);

        Ok(Some(&self.image[start..end]))
    }

    fn to_ascii(s: &str) -> Result<&[u8], LibError>
    {
        let bytes = s.as_bytes();
        
        if bytes.iter().any(|s| *s < 0x20 || *s > 0x7e) {
            return Err(LibError::new("names must be ASCII"));
        }

        Ok(bytes)
    }

    fn rotr(x: u16, bits: usize) -> u16 {
        ((x) << (16-bits)) | ((x) >> bits)
    }

    fn rotl(x: u16, bits: usize) -> u16 {
        ((x) << bits) | ((x) >> (16-bits))
    }

    fn hash(&self, name: &[u8]) -> LibHash {
        const BLANK: u16 = 0x20u16;
        let mut len = name.len() as u16;

        let mut block_x = len | BLANK;
        let mut bucket_d = block_x;
        let mut block_d = 0;
        let mut bucket_x;

        let mut pb = 0;
        let mut pe = name.len();

        loop {
            pe -= 1;
            let cback = name[pe] as u16 | BLANK;
            bucket_x = Self::rotr(block_x, 2) ^ cback;
            block_d = Self::rotl(block_d, 2) ^ cback;
            len -= 1;
            if len == 0 {
                break;
            }
            let cfront = name[pb] as u16 | BLANK;
            pb += 1;
            block_x = Self::rotl(block_x, 2) ^ cfront;
            bucket_d = Self::rotr(bucket_d, 2) ^ cfront;
        }

        LibHash{
            block_x: block_x % self.dictblocks as u16,
            bucket_d: max(bucket_d % LIB_NBUCKETS as u16, 1),
            block_d: max(block_d % self.dictblocks as u16, 1),
            bucket_x: bucket_x % LIB_NBUCKETS as u16,
        }
    }


    pub fn find_symbol_obj(&self, name: &str) -> Result<Option<usize>, LibError> {
        let ascname = Self::to_ascii(name)?;
        let hash = self.hash(ascname);

        let mut block = hash.block_x as usize;
        let bucket = hash.bucket_x as usize;

        loop {
            let mut b0 = bucket;
            let offset = self.dictoffset + block * LIB_BLOCK_SIZE;
            let buf = &self.image[offset..offset+LIB_BLOCK_SIZE];


            loop {
                let mut idx = 2 * buf[b0 as usize] as usize;
                let len = buf[idx] as usize;
                idx += 1;

                let thisname = &buf[idx..idx+len];
                if ascname == thisname {
                    idx += len;
                    let modindex = Self::uint(&buf[idx..idx+2]) as u16;
                    
                    return Ok(Some(modindex as usize));
                }
                
                b0 = (b0 + hash.bucket_d as usize) % LIB_NBUCKETS;
                if b0 == bucket {
                    break;
                }
            }

            block = (block + hash.block_d as usize) % self.dictblocks;
            if block == hash.block_x as usize {
                break;
            }
        }

        Ok(None)
    }

    pub fn find_module_index(&self, modpage: usize) -> Option<usize> {
        match &self.edict {
            None => None,
            Some(edict) => {
                let data = &self.image[edict.offset..self.image.len()];
                // NB collection is 1-based not zero-based
                (1..edict.entries+1)
                    .find(|f: &usize| Self::uint(&data[(f-1)*4..(f-1)*4+2]) == modpage)
            }
        }
    }

    pub fn find_module_dependencies(&self, modpage: usize) -> Result<Option<Vec<usize>>, LibError> {
        match &self.edict {
            None => Ok(None),
            Some(edict) => match self.find_module_index(modpage) {
                Some(index) => {
                    let data = &self.image[edict.offset..self.image.len()];
                    let index = index - 1;    
                    let mut offset = Self::uint(&data[index*4+2..index*4+4]);
                    let mut deps = Vec::new();
                    while offset <= data.len() - 2 {
                        let next = Self::uint(&data[offset..offset+2]);
                        if next == 0 {
                            return Ok(Some(deps));
                        }

                        // convert dep index to dep page# of module
                        let next = (next - 1) * 4;
                        let next = Self::uint(&data[next..next+2]);
                        deps.push(next);
                        offset += 2;
                    }

                    Err(self.err("library extended dictionary is truncated"))
                },
                None => Ok(None),
            }
                
        }
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_is_lib_succeeds() {
        let bytes = vec![
            0xf0, 
            16-3, 0, 
            0x10, 0x00, 0x00, 0x00,
            0x03, 0x00,
            0x00,
            0, 0, 0,  0, 0, 0,
            
            // stub dict
            0
        ];

        assert!(Parser::is_lib(&bytes));
        let parser = Parser::new(&bytes);
        match parser {
            Err(x) => assert!(false, "parser returned error {}", x),
            Ok(parser) => {
                assert_eq!(parser.pagesize, 16);
                assert_eq!(parser.dictoffset, 0x0010);
                assert_eq!(parser.dictblocks, 3);
            },
        };
    }

    #[test]
    fn test_is_lib_false_too_short() {
        let bytes = [
            0xf0, 
            16-3, 0, 
            0x00, 0x02, 0x00, 0x00,
            0x03, 0x00,
        ];

        assert!(!Parser::is_lib(&bytes));
    }

    #[test]
    fn test_is_lib_false_wrong_header() {
        let bytes = [
            0x80, 
            16-3, 0, 
            0x00, 0x02, 0x00, 0x00,
            0x03, 0x00,
            0x00,
        ];

        assert!(!Parser::is_lib(&bytes));
    }

    #[test]
    fn test_parser_fails_if_dictoffset_is_out_of_bounds() {
        let bytes = [
            0xf0, 
            16-3, 0, 
            0x00, 0x02, 0x00, 0x00,
            0x03, 0x00,
            0x00, 
        ];

        assert!(Parser::new(&bytes).is_err());
    }

    #[test]
    fn test_first_obj_succeeds() {
        let bytes = vec![
            0xf0, 16-3, 0, 0x30, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x80, 0x05, 0x00, 0x03, 0x41, 0x42, 0x43, 0x00,
            0x8a, 0x02, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00,
            0x80, 0x05, 0x00, 0x03, 0x44, 0x45, 0x46, 0x00,
            0x8a, 0x02, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00,

            // stub dict
            0
        ];

        assert!(Parser::is_lib(&bytes));
        let parser = Parser::new(&bytes);
        match parser {
            Err(x) => assert!(false, "parser returned error {}", x),
            Ok(mut parser) => {
                assert_eq!(parser.pagesize, 16);
                assert_eq!(parser.dictoffset, 48);
                assert_eq!(parser.dictblocks, 3);

                match parser.first_obj() {
                    Ok(fo) =>assert_eq!(fo, Some(&bytes[16..29])),
                    Err(e) => assert!(false, "parser failed on first object {}", e),
                }

            },
        };
    }

    #[test]
    fn test_next_obj_succeeds() {
        let bytes = vec![
            0xf0, 16-3, 0, 0x30, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x80, 0x05, 0x00, 0x03, 0x41, 0x42, 0x43, 0x00,
            0x8a, 0x02, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00,
            0x80, 0x05, 0x00, 0x03, 0x44, 0x45, 0x46, 0x00,
            0x8a, 0x02, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00,

            // stub dict
            0
        ];

        assert!(Parser::is_lib(&bytes));
        let parser = Parser::new(&bytes);
        assert!(parser.is_ok());
        let mut parser = parser.unwrap();
        assert!(parser.first_obj().is_ok());
        
        match parser.next_obj() {
            Ok(no) =>assert_eq!(no, Some(&bytes[32..32+13])),
            Err(e) => assert!(false, "parser failed on first object {}", e),
        };
    }

    #[test]
    fn test_next_obj_succeeds_on_end_of_modules() {
        let bytes = vec![
            0xf0, 0x0d, 0x00, 0x20, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x80, 0x05, 0x00, 0x03, 0x41, 0x42, 0x43, 0x00, 0x8a, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            
            // stub dict
            0
        ];

        assert!(Parser::is_lib(&bytes));
        let parser = Parser::new(&bytes);
        assert!(parser.is_ok());
        let mut parser = parser.unwrap();
        assert!(parser.first_obj().is_ok());
        
        match parser.next_obj() {
            Ok(no) =>assert_eq!(no, None),
            Err(e) => assert!(false, "parser failed on first object {}", e),
        };
    }

    #[test]
    fn test_find_symbol_obj_succeeds() {
        let bytes = shortlib();
        
        match Parser::new(&bytes) {
            Err(e) => assert!(false, "failed to parse lib {}", e),
            Ok(parser) => {
                match parser.find_symbol_obj("_main") {
                    Err(e) => assert!(false, "failed to search for name {}", e),
                    Ok(sym) => assert_eq!(sym, Some(0x001b)),
                }
            }
        }
    }

    #[test]
    fn test_find_edict_succeeds() {
        let bytes = shortlib();
        
        match Parser::new(&bytes) {
            Err(e) => assert!(false, "failed to parse lib {}", e),
            Ok(parser) => {
                match parser.edict {
                    Some(edict) => {
                        assert_eq!(edict.offset, EDICT_OFFSET);
                        assert_eq!(edict.entries, EDICT_ENTRIES);
                    },
                    None => assert!(false, "parser didn't find edict"),
                }
            }
        }
    }


    #[test]
    fn test_find_no_edict_succeeds() {
        let bytes = shortlib();
        
        match Parser::new(&bytes[0..EDICT_START]) {
            Err(e) => assert!(false, "failed to parse lib {}", e),
            Ok(parser) => {
                assert!(parser.edict.is_none());
            }
        }
    }

    #[test]
    fn test_find_module_index_succeeds() {
        let bytes = shortlib();
        
        match Parser::new(&bytes) {
            Err(e) => assert!(false, "failed to parse lib {}", e),
            Ok(parser) => {
                // 0x001b is module #2; modules are 1-indexed
                //
                assert_eq!(parser.find_module_index(0x001b), Some(2));
            }
        }        
    }

    #[test]
    fn test_find_module_index_no_such_module_succeeds() {
        let bytes = shortlib();
        
        match Parser::new(&bytes) {
            Err(e) => assert!(false, "failed to parse lib {}", e),
            Ok(parser) => {
                // 0x001b is module #2; modules are 1-indexed
                //
                assert_eq!(parser.find_module_index(0x001c), None);
            }
        }        
    }

    #[test]
    fn test_find_empty_module_deps_succeeds() {
        let bytes = shortlib();
        
        match Parser::new(&bytes) {
            Err(e) => assert!(false, "failed to parse lib {}", e),
            Ok(parser) => {
                // module 0x0001 exists but has no dependencies
                //
                match parser.find_module_dependencies(0x0001) {
                    Err(e) => assert!(false, "find_module_dependencies failed {}", e),
                    Ok(v) => assert_eq!(v, Some(vec![])),
                }
            }        
        }
    }

    #[test]
    fn test_find_module_deps_succeeds() {
        let bytes = shortlib();
        
        match Parser::new(&bytes) {
            Err(e) => assert!(false, "failed to parse lib {}", e),
            Ok(parser) => {
                // module 0x001b exists and depends on module at 0x0001
                //
                match parser.find_module_dependencies(0x001b) {
                    Err(e) => assert!(false, "find_module_dependencies failed {}", e),
                    Ok(v) => assert_eq!(v, Some(vec![0x0001])),
                }
            }
        }        
    }

    #[test]
    fn test_find_module_deps_fails() {
        let bytes = shortlib();
        
        match Parser::new(&bytes) {
            Err(e) => assert!(false, "failed to parse lib {}", e),
            Ok(parser) => {
                // module 0x001c does not exist
                //
                match parser.find_module_dependencies(0x001c) {
                    Err(e) => assert!(false, "find_module_dependencies failed {}", e),
                    Ok(v) => assert_eq!(v, None),
                }
            }
        }        
    }

    #[test]
    fn test_find_truncated_module_deps_fails() {
        let bytes = shortlib();
        
        match Parser::new(&bytes[0..bytes.len()-2]) {
            Err(e) => assert!(false, "failed to parse lib {}", e),
            Ok(parser) => {
                // module 0x001b exists but we have truncated the 0 terminator
                // off the end of the edict.
                //
                assert!(parser.find_module_dependencies(0x001b).is_err());
            }
        }        
    }

    const EDICT_START: usize = 0x0800;
    const EDICT_OFFSET: usize = 0x0805;
    const EDICT_ENTRIES: usize = 2;

    fn shortlib() -> Vec<u8> {
        vec![
            0xf0, 0x0d, 0x00, 0x00, 0x04, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x80, 0x09, 0x00, 0x07, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x2e, 0x63, 0xcb, 0x88, 0x09, 0x00, 0x00,
            0xa3, 0x05, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0xb3, 0x88, 0x06, 0x00, 0x00, 0xa1, 0x01, 0x43, 0x56,
            0x00, 0x96, 0x3f, 0x00, 0x00, 0x04, 0x43, 0x4f, 0x44, 0x45, 0x04, 0x44, 0x41, 0x54, 0x41, 0x05,
            0x43, 0x4f, 0x4e, 0x53, 0x54, 0x03, 0x42, 0x53, 0x53, 0x08, 0x46, 0x41, 0x52, 0x5f, 0x44, 0x41,
            0x54, 0x41, 0x09, 0x24, 0x24, 0x53, 0x59, 0x4d, 0x42, 0x4f, 0x4c, 0x53, 0x06, 0x44, 0x45, 0x42,
            0x53, 0x59, 0x4d, 0x07, 0x24, 0x24, 0x54, 0x59, 0x50, 0x45, 0x53, 0x06, 0x44, 0x45, 0x42, 0x54,
            0x59, 0x50, 0x00, 0x96, 0x1f, 0x00, 0x05, 0x5f, 0x54, 0x45, 0x58, 0x54, 0x05, 0x5f, 0x44, 0x41,
            0x54, 0x41, 0x05, 0x43, 0x4f, 0x4e, 0x53, 0x54, 0x04, 0x5f, 0x42, 0x53, 0x53, 0x06, 0x44, 0x47,
            0x52, 0x4f, 0x55, 0x50, 0x00, 0x98, 0x07, 0x00, 0x48, 0x1b, 0x00, 0x0b, 0x02, 0x01, 0x00, 0x98,
            0x07, 0x00, 0x48, 0x0f, 0x00, 0x0c, 0x03, 0x01, 0x00, 0x98, 0x07, 0x00, 0x48, 0x00, 0x00, 0x0d,
            0x04, 0x01, 0x00, 0x98, 0x07, 0x00, 0x48, 0x00, 0x00, 0x0e, 0x05, 0x01, 0x00, 0x99, 0x09, 0x00,
            0x21, 0x00, 0x00, 0x00, 0x00, 0x07, 0x08, 0x01, 0x00, 0x99, 0x09, 0x00, 0x21, 0x00, 0x00, 0x00,
            0x00, 0x09, 0x0a, 0x01, 0x00, 0x9a, 0x08, 0x00, 0x0f, 0xff, 0x02, 0xff, 0x03, 0xff, 0x04, 0x00,
            0x9c, 0x0b, 0x00, 0x10, 0x01, 0x11, 0x02, 0x12, 0x03, 0x13, 0x04, 0x44, 0x01, 0x00, 0x88, 0x05,
            0x00, 0x00, 0x9d, 0x30, 0x73, 0x00, 0x88, 0x0f, 0x00, 0x00, 0x9f, 0x4f, 0x4c, 0x44, 0x4e, 0x41,
            0x4d, 0x45, 0x53, 0x2e, 0x4c, 0x49, 0x42, 0x00, 0x88, 0x09, 0x00, 0x00, 0x9f, 0x53, 0x4c, 0x49,
            0x42, 0x43, 0x45, 0x00, 0xb0, 0x0b, 0x00, 0x04, 0x5f, 0x66, 0x6f, 0x6f, 0x00, 0x62, 0x81, 0xc8,
            0x00, 0x00, 0x8c, 0x16, 0x00, 0x0a, 0x5f, 0x5f, 0x61, 0x4e, 0x63, 0x68, 0x6b, 0x73, 0x74, 0x6b,
            0x00, 0x07, 0x5f, 0x70, 0x72, 0x69, 0x6e, 0x74, 0x66, 0x00, 0x00, 0xa0, 0x1f, 0x00, 0x01, 0x00,
            0x00, 0x55, 0x8b, 0xec, 0xb8, 0x00, 0x00, 0xe8, 0x00, 0x00, 0x56, 0x57, 0xb8, 0x00, 0x00, 0x50,
            0xe8, 0x00, 0x00, 0x83, 0xc4, 0x02, 0x5f, 0x5e, 0x8b, 0xe5, 0x5d, 0xc3, 0x00, 0x9c, 0x0c, 0x00,
            0x84, 0x07, 0x56, 0x02, 0xc4, 0x0c, 0x8d, 0x84, 0x10, 0x56, 0x03, 0x00, 0xa0, 0x13, 0x00, 0x02,
            0x00, 0x00, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x21, 0x0a,
            0x00, 0x00, 0x90, 0x0d, 0x00, 0x00, 0x01, 0x06, 0x5f, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x00, 0x00,
            0x00, 0x00, 0xb2, 0x07, 0x00, 0x01, 0x01, 0x04, 0x00, 0x02, 0x00, 0x00, 0x8a, 0x02, 0x00, 0x30,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x80, 0x08, 0x00, 0x06, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x63, 0x3c, 0x88, 0x08, 0x00, 0x00, 0xa3,
            0x04, 0x6d, 0x61, 0x69, 0x6e, 0x24, 0x88, 0x06, 0x00, 0x00, 0xa1, 0x01, 0x43, 0x56, 0x00, 0x96,
            0x3f, 0x00, 0x00, 0x04, 0x43, 0x4f, 0x44, 0x45, 0x04, 0x44, 0x41, 0x54, 0x41, 0x05, 0x43, 0x4f,
            0x4e, 0x53, 0x54, 0x03, 0x42, 0x53, 0x53, 0x08, 0x46, 0x41, 0x52, 0x5f, 0x44, 0x41, 0x54, 0x41,
            0x09, 0x24, 0x24, 0x53, 0x59, 0x4d, 0x42, 0x4f, 0x4c, 0x53, 0x06, 0x44, 0x45, 0x42, 0x53, 0x59,
            0x4d, 0x07, 0x24, 0x24, 0x54, 0x59, 0x50, 0x45, 0x53, 0x06, 0x44, 0x45, 0x42, 0x54, 0x59, 0x50,
            0x00, 0x96, 0x1f, 0x00, 0x05, 0x5f, 0x54, 0x45, 0x58, 0x54, 0x05, 0x5f, 0x44, 0x41, 0x54, 0x41,
            0x05, 0x43, 0x4f, 0x4e, 0x53, 0x54, 0x04, 0x5f, 0x42, 0x53, 0x53, 0x06, 0x44, 0x47, 0x52, 0x4f,
            0x55, 0x50, 0x00, 0x98, 0x07, 0x00, 0x48, 0x1e, 0x00, 0x0b, 0x02, 0x01, 0x00, 0x98, 0x07, 0x00,
            0x48, 0x00, 0x00, 0x0c, 0x03, 0x01, 0x00, 0x98, 0x07, 0x00, 0x48, 0x00, 0x00, 0x0d, 0x04, 0x01,
            0x00, 0x98, 0x07, 0x00, 0x48, 0x00, 0x00, 0x0e, 0x05, 0x01, 0x00, 0x99, 0x09, 0x00, 0x21, 0x00,
            0x00, 0x00, 0x00, 0x07, 0x08, 0x01, 0x00, 0x99, 0x09, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0x09,
            0x0a, 0x01, 0x00, 0x9a, 0x08, 0x00, 0x0f, 0xff, 0x02, 0xff, 0x03, 0xff, 0x04, 0x00, 0x9c, 0x0b,
            0x00, 0x10, 0x01, 0x11, 0x02, 0x12, 0x03, 0x13, 0x04, 0x44, 0x01, 0x00, 0x88, 0x05, 0x00, 0x00,
            0x9d, 0x30, 0x73, 0x00, 0x88, 0x0f, 0x00, 0x00, 0x9f, 0x4f, 0x4c, 0x44, 0x4e, 0x41, 0x4d, 0x45,
            0x53, 0x2e, 0x4c, 0x49, 0x42, 0x00, 0x88, 0x09, 0x00, 0x00, 0x9f, 0x53, 0x4c, 0x49, 0x42, 0x43,
            0x45, 0x00, 0xb0, 0x0b, 0x00, 0x04, 0x5f, 0x66, 0x6f, 0x6f, 0x00, 0x62, 0x81, 0x2c, 0x01, 0x00,
            0x8c, 0x0d, 0x00, 0x0a, 0x5f, 0x5f, 0x61, 0x63, 0x72, 0x74, 0x75, 0x73, 0x65, 0x64, 0x00, 0x00,
            0x8c, 0x15, 0x00, 0x0a, 0x5f, 0x5f, 0x61, 0x4e, 0x63, 0x68, 0x6b, 0x73, 0x74, 0x6b, 0x00, 0x06,
            0x5f, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x00, 0x00, 0xa0, 0x22, 0x00, 0x01, 0x00, 0x00, 0x55, 0x8b,
            0xec, 0xb8, 0x00, 0x00, 0xe8, 0x00, 0x00, 0x56, 0x57, 0xc6, 0x06, 0x00, 0x00, 0x2a, 0xc6, 0x06,
            0x01, 0x00, 0x00, 0xe8, 0x00, 0x00, 0x5f, 0x5e, 0x8b, 0xe5, 0x5d, 0xc3, 0x00, 0x9c, 0x11, 0x00,
            0x84, 0x07, 0x56, 0x03, 0xc4, 0x0d, 0x56, 0x01, 0xc4, 0x12, 0x56, 0x01, 0x84, 0x16, 0x56, 0x04,
            0x00, 0x90, 0x0c, 0x00, 0x00, 0x01, 0x05, 0x5f, 0x6d, 0x61, 0x69, 0x6e, 0x00, 0x00, 0x00, 0x00,
            0xb2, 0x07, 0x00, 0x01, 0x01, 0x04, 0x00, 0x02, 0x00, 0x00, 0x8a, 0x02, 0x00, 0x30, 0x00, 0x00,
            0xf1, 0xbd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x05, 0x6d, 0x61, 0x69, 0x6e, 0x21, 0x1b, 0x00, 0x06, 0x5f,
            0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x06, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x21, 0x01, 0x00, 0x00,
            0x05, 0x5f, 0x6d, 0x61, 0x69, 0x6e, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xf2, 0x14, 0x00, 0x02, 0x00, 0x01, 0x00, 0x0c, 0x00, 0x1b, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        ]
    }
}